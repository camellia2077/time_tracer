from __future__ import annotations

import tomllib
from pathlib import Path
from typing import Any

from .constants import REPORT_FORMAT_ORDER, REPORT_PERIOD_KEYS
from .model import BundleModel
from .path_utils import dedupe_keep_order, normalize_rel_path
from .validation import ensure_dict, ensure_list_of_str, ensure_str


def parse_report_paths(reports_table: dict[str, Any], format_name: str) -> dict[str, str]:
    format_table = ensure_dict(reports_table.get(format_name), f"paths.reports.{format_name}")
    parsed: dict[str, str] = {}
    for key in REPORT_PERIOD_KEYS:
        parsed[key] = normalize_rel_path(
            ensure_str(format_table.get(key), f"paths.reports.{format_name}.{key}")
        )
    return parsed


def load_source_bundle(source_root: Path) -> dict[str, Any]:
    bundle_path = source_root / "meta" / "bundle.toml"
    if not bundle_path.exists():
        raise FileNotFoundError(f"Source bundle not found: {bundle_path}")
    data = tomllib.loads(bundle_path.read_text(encoding="utf-8"))
    return ensure_dict(data, "root")


def build_bundle_model(source_bundle: dict[str, Any], target: str) -> BundleModel:
    schema_version_raw = source_bundle.get("schema_version")
    if not isinstance(schema_version_raw, int):
        raise ValueError("Expected integer at 'schema_version'.")

    bundle_name = ensure_str(source_bundle.get("bundle_name"), "bundle_name")

    file_list = ensure_dict(source_bundle.get("file_list"), "file_list")
    source_required = ensure_list_of_str(file_list.get("required"), "file_list.required")
    source_optional = ensure_list_of_str(file_list.get("optional"), "file_list.optional")

    paths_table = ensure_dict(source_bundle.get("paths"), "paths")
    converter_table = ensure_dict(paths_table.get("converter"), "paths.converter")
    interval_config = normalize_rel_path(
        ensure_str(converter_table.get("interval_config"), "paths.converter.interval_config")
    )

    reports_table = ensure_dict(paths_table.get("reports"), "paths.reports")
    markdown_paths = parse_report_paths(reports_table, "markdown")

    if target == "android":
        converter_files = dedupe_keep_order(
            [path for path in source_required + source_optional if path.startswith("converter/")]
        )
        required_files = dedupe_keep_order(
            ["config.toml", *converter_files, interval_config, *markdown_paths.values()]
        )
        return BundleModel(
            schema_version=schema_version_raw,
            profile="android",
            bundle_name=bundle_name,
            required_files=required_files,
            optional_files=[],
            converter_interval_config=interval_config,
            reports={"markdown": markdown_paths},
        )

    windows_reports: dict[str, dict[str, str]] = {}
    for format_name in REPORT_FORMAT_ORDER:
        if format_name in reports_table:
            windows_reports[format_name] = parse_report_paths(reports_table, format_name)
    if "markdown" not in windows_reports:
        raise ValueError("Windows bundle generation requires paths.reports.markdown.")

    required_files = dedupe_keep_order(["config.toml", interval_config, *source_required])
    optional_files = dedupe_keep_order(source_optional)
    return BundleModel(
        schema_version=schema_version_raw,
        profile="windows",
        bundle_name=bundle_name,
        required_files=required_files,
        optional_files=optional_files,
        converter_interval_config=interval_config,
        reports=windows_reports,
    )


def render_bundle_toml(model: BundleModel) -> str:
    lines: list[str] = [
        "# Auto-generated by scripts/platform_config/run.py.",
        "# Source of truth: apps/time_tracer/config",
        "",
        f"schema_version = {model.schema_version}",
        f'profile = "{model.profile}"',
        f'bundle_name = "{model.bundle_name}"',
        "",
        "[file_list]",
        "required = [",
    ]
    for path in model.required_files:
        lines.append(f'  "{path}",')
    lines.extend(["]", "optional = ["])
    for path in model.optional_files:
        lines.append(f'  "{path}",')
    lines.extend(["]", "", "[paths.converter]"])
    lines.append(f'interval_config = "{model.converter_interval_config}"')

    for format_name in REPORT_FORMAT_ORDER:
        section = model.reports.get(format_name)
        if section is None:
            continue
        lines.append("")
        lines.append(f"[paths.reports.{format_name}]")
        for key in REPORT_PERIOD_KEYS:
            lines.append(f'{key} = "{section[key]}"')

    lines.append("")
    return "\n".join(lines)


def build_android_config_toml(source_root: Path) -> str:
    source_config_path = source_root / "config.toml"
    text = source_config_path.read_text(encoding="utf-8")
    lines = text.splitlines(keepends=True)

    disallowed_tables = {"reports.typst", "reports.latex"}
    output_lines: list[str] = []
    skip_block = False
    for line in lines:
        stripped = line.strip()
        if stripped.startswith("[") and stripped.endswith("]"):
            table_name = stripped[1:-1].strip()
            skip_block = table_name in disallowed_tables
            if skip_block:
                continue
        if not skip_block:
            output_lines.append(line)

    output = "".join(output_lines)
    if output and not output.endswith("\n"):
        output += "\n"
    return output
