// api/cli/impl/utils/console_helper.cpp
#include "api/cli/impl/utils/console_helper.hpp"

#include <algorithm>
#include <iomanip>
#include <map>
#include <set>
#include <sstream>
#include <string_view>

#include "api/cli/framework/core/arg_definitions.hpp"
#include "api/cli/framework/core/command_catalog.hpp"
#include "api/cli/framework/interfaces/i_command.hpp"
#include "shared/types/ansi_colors.hpp"

#if defined(_WIN32) || defined(_WIN64)
#include <windows.h>
// clang-format off
#include <shellapi.h>
// clang-format on
#endif

namespace ConsoleHelper {

namespace {

#if defined(_WIN32) || defined(_WIN64)
auto WideToUtf8(const wchar_t *text) -> std::string {
  if (text == nullptr) {
    return {};
  }
  int required =
      WideCharToMultiByte(CP_UTF8, 0, text, -1, nullptr, 0, nullptr, nullptr);
  if (required <= 1) {
    return {};
  }
  std::string result(static_cast<size_t>(required - 1), '\0');
  WideCharToMultiByte(CP_UTF8, 0, text, -1, result.data(), required, nullptr,
                      nullptr);
  return result;
}

void EnableVirtualTerminalProcessingForHandle(DWORD handle_kind) {
  HANDLE handle = GetStdHandle(handle_kind);
  if (handle == INVALID_HANDLE_VALUE || handle == nullptr) {
    return;
  }

  DWORD mode = 0;
  if (GetConsoleMode(handle, &mode) == 0) {
    return;
  }

  mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
  SetConsoleMode(handle, mode);
}
#endif

constexpr int kUsageNameMinWidth = 15;
constexpr int kArgumentColumnWidth = 20;
constexpr std::string_view kAutoGeneratedHelp = "Auto generated help...";

struct ArgGroups {
  std::vector<ArgDef> positionals;
  std::vector<ArgDef> options;
};

struct UsageCommandEntry {
  std::string name;
  const ICommand *command = nullptr;
};

auto SplitArgDefinitions(const std::vector<ArgDef> &definitions) -> ArgGroups {
  ArgGroups groups;
  for (const auto &def : definitions) {
    if (def.type == ArgType::kPositional) {
      groups.positionals.push_back(def);
    } else {
      groups.options.push_back(def);
    }
  }

  std::ranges::sort(
      groups.positionals,
      [](const ArgDef &left_def, const ArgDef &right_def) -> bool {
        return left_def.position_index < right_def.position_index;
      });

  return groups;
}

auto BuildUsagePrefix(const std::string &name, int usage_name_width)
    -> std::string {
  std::stringstream usage_stream;
  usage_stream << "  " << tracer_core::common::colors::kCyan << std::left
               << std::setw(usage_name_width) << name
               << tracer_core::common::colors::kReset;
  return usage_stream.str();
}

auto NormalizeDescription(std::string description) -> std::string {
  if (description == kAutoGeneratedHelp) {
    return std::string{};
  }
  return description;
}

auto ToSummaryDescription(std::string description) -> std::string {
  std::string normalized = NormalizeDescription(std::move(description));
  const std::size_t first_line_end = normalized.find_first_of("\r\n");
  if (first_line_end != std::string::npos) {
    normalized.resize(first_line_end);
  }
  return normalized;
}

auto ResolveCategoryFromCatalog(const std::string &command_name,
                                const ICommand *command) -> std::string {
  if (const auto *spec =
          tracer_core::cli::framework::core::FindCommandSpec(command_name);
      spec != nullptr && !spec->category.empty()) {
    return std::string(spec->category);
  }
  if (command != nullptr) {
    return command->GetCategory();
  }
  return "General";
}

auto ResolveSummaryFromCatalog(const std::string &command_name,
                               const ICommand *command) -> std::string {
  if (const auto *spec =
          tracer_core::cli::framework::core::FindCommandSpec(command_name);
      spec != nullptr && !spec->summary.empty()) {
    return std::string(spec->summary);
  }
  if (command != nullptr) {
    return NormalizeDescription(command->GetHelp());
  }
  return {};
}

auto FormatOptionKeys(const std::vector<std::string> &keys) -> std::string {
  std::stringstream keys_stream;
  for (size_t index = 0; index < keys.size(); ++index) {
    keys_stream << keys[index];
    if (index + 1 < keys.size()) {
      keys_stream << ", ";
    }
  }
  return keys_stream.str();
}

void PrintUsageLine(const std::string &usage_prefix,
                    const std::string &description) {
  std::cout << usage_prefix << " " << description << "\n";
}

void PrintUsageSignature(const std::string &name, const ArgGroups &groups) {
  std::cout << "    " << tracer_core::common::colors::kBold << "Usage: " << name
            << tracer_core::common::colors::kReset;
  for (const auto &positional : groups.positionals) {
    std::cout << " " << tracer_core::common::colors::kCyan << "<"
              << positional.name << ">" << tracer_core::common::colors::kReset;
  }
  if (!groups.options.empty()) {
    std::cout << " " << tracer_core::common::colors::kGray << "[options]"
              << tracer_core::common::colors::kReset;
  }
  std::cout << "\n";
}

void PrintPositionals(const std::vector<ArgDef> &positionals) {
  if (positionals.empty()) {
    return;
  }

  for (const auto &def : positionals) {
    std::cout << "      " << std::left << std::setw(kArgumentColumnWidth)
              << (std::string(tracer_core::common::colors::kCyan) + "<" +
                  def.name + ">" +
                  std::string(tracer_core::common::colors::kReset))
              << ": " << def.help
              << (def.required
                      ? (std::string(tracer_core::common::colors::kGray) +
                         " (Required)" +
                         std::string(tracer_core::common::colors::kReset))
                      : "")
              << "\n";
  }
}

void PrintOptions(const std::vector<ArgDef> &options) {
  if (options.empty()) {
    return;
  }

  for (const auto &def : options) {
    std::cout << "      " << std::left << std::setw(kArgumentColumnWidth)
              << (std::string(tracer_core::common::colors::kCyan) +
                  FormatOptionKeys(def.keys) +
                  std::string(tracer_core::common::colors::kReset))
              << ": " << def.help << "\n";
  }
}

} // namespace

#if defined(_WIN32) || defined(_WIN64)
void SetupConsole() {
  SetConsoleOutputCP(CP_UTF8);
  EnableVirtualTerminalProcessingForHandle(STD_OUTPUT_HANDLE);
  EnableVirtualTerminalProcessingForHandle(STD_ERROR_HANDLE);
}

auto GetUtf8Args() -> std::vector<std::string> {
  int argc = 0;
  LPWSTR *argv = CommandLineToArgvW(GetCommandLineW(), &argc);
  if (argv == nullptr || argc == 0) {
    return {};
  }
  std::vector<std::string> args;
  args.reserve(static_cast<size_t>(argc));
  for (int i = 0; i < argc; ++i) {
    args.emplace_back(WideToUtf8(argv[i]));
  }
  LocalFree(static_cast<void *>(argv));
  return args;
}
#endif

void PrintFullUsage(
    const char *app_name,
    const std::vector<std::pair<std::string, std::unique_ptr<ICommand>>>
        &commands) {
  std::cout << tracer_core::common::colors::kBrightGreen
            << tracer_core::common::colors::kBold << "TimeTracer"
            << tracer_core::common::colors::kReset
            << ": A command-line tool for time data processing.\n\n";
  std::cout << tracer_core::common::colors::kBold
            << "Usage: " << tracer_core::common::colors::kReset << app_name
            << " " << tracer_core::common::colors::kCyan << "<command>"
            << tracer_core::common::colors::kReset
            << " [arguments...] [options...]\n\n";

  std::cout << tracer_core::common::colors::kBold
            << "Available Commands:" << tracer_core::common::colors::kReset
            << "\n";

  std::map<std::string, std::vector<UsageCommandEntry>> grouped_commands;
  std::set<std::string> known_commands;
  int usage_name_width = kUsageNameMinWidth;
  for (const auto &[name, cmd_ptr] : commands) {
    if (!cmd_ptr) {
      continue;
    }
    const std::string category =
        ResolveCategoryFromCatalog(name, cmd_ptr.get());
    usage_name_width =
        std::max(usage_name_width, static_cast<int>(name.size()) + 1);
    grouped_commands[category].push_back(UsageCommandEntry{
        .name = name,
        .command = cmd_ptr.get(),
    });
    known_commands.insert(name);
  }

  for (const auto &spec :
       tracer_core::cli::framework::core::GetCommandSpecs()) {
    const std::string name(spec.name);
    if (known_commands.contains(name)) {
      continue;
    }
    const std::string category = ResolveCategoryFromCatalog(name, nullptr);
    usage_name_width =
        std::max(usage_name_width, static_cast<int>(name.size()) + 1);
    grouped_commands[category].push_back(UsageCommandEntry{
        .name = name,
        .command = nullptr,
    });
  }

  const std::vector<std::string> kCategoryOrder = {
      "Query", "Chart", "Crypto", "Export", "Pipeline", "General"};

  for (const auto &category : kCategoryOrder) {
    if (grouped_commands.contains(category)) {
      std::cout << "\n  " << tracer_core::common::colors::kBold << category
                << ":" << tracer_core::common::colors::kReset << "\n";
      for (const auto &entry : grouped_commands[category]) {
        std::string description = ToSummaryDescription(
            ResolveSummaryFromCatalog(entry.name, entry.command));
        std::string usage_prefix =
            BuildUsagePrefix(entry.name, usage_name_width);
        PrintUsageLine(usage_prefix, description);
      }
      grouped_commands.erase(category);
    }
  }

  for (const auto &[category, entries] : grouped_commands) {
    std::cout << "\n  " << tracer_core::common::colors::kBold << category << ":"
              << tracer_core::common::colors::kReset << "\n";
    for (const auto &entry : entries) {
      std::string description = ToSummaryDescription(
          ResolveSummaryFromCatalog(entry.name, entry.command));
      std::string usage_prefix = BuildUsagePrefix(entry.name, usage_name_width);
      PrintUsageLine(usage_prefix, description);
    }
  }

  std::cout << "\n"
            << tracer_core::common::colors::kBold
            << "Global Options:" << tracer_core::common::colors::kReset << "\n";
  std::cout << "  " << tracer_core::common::colors::kCyan << "--help, -h"
            << tracer_core::common::colors::kReset
            << "          Show this help message.\n";
  std::cout << "  " << tracer_core::common::colors::kCyan << "--version, -v"
            << tracer_core::common::colors::kReset
            << "       Show program version.\n";
  std::cout << "\nRun '" << app_name << " "
            << tracer_core::common::colors::kCyan << "<command> --help"
            << tracer_core::common::colors::kReset
            << "' for command-specific usage.\n";
}

void PrintCommandUsage(const std::string &command_name,
                       const ICommand &command) {
  std::cout << tracer_core::common::colors::kBrightGreen
            << tracer_core::common::colors::kBold << "Command: " << command_name
            << tracer_core::common::colors::kReset << "\n\n";

  ArgGroups groups = SplitArgDefinitions(command.GetDefinitions());
  std::string description = ResolveSummaryFromCatalog(command_name, &command);

  if (!description.empty()) {
    std::cout << "  " << description << "\n\n";
  }

  PrintUsageSignature(command_name, groups);
  PrintPositionals(groups.positionals);
  PrintOptions(groups.options);
  std::cout << "\n";
}

} // namespace ConsoleHelper
