// api/cli/impl/utils/console_helper.cpp
#include "api/cli/impl/utils/console_helper.hpp"

#include <algorithm>
#include <iomanip>
#include <map>
#include <sstream>
#include <string_view>

#include "api/cli/framework/core/arg_definitions.hpp"
#include "api/cli/framework/interfaces/i_command.hpp"
#include "shared/types/ansi_colors.hpp"

#if defined(_WIN32) || defined(_WIN64)
#include <windows.h>
// clang-format off
#include <shellapi.h>
// clang-format on
#endif

namespace ConsoleHelper {

namespace {

#if defined(_WIN32) || defined(_WIN64)
auto WideToUtf8(const wchar_t* text) -> std::string {
  if (text == nullptr) {
    return {};
  }
  int required =
      WideCharToMultiByte(CP_UTF8, 0, text, -1, nullptr, 0, nullptr, nullptr);
  if (required <= 1) {
    return {};
  }
  std::string result(static_cast<size_t>(required - 1), '\0');
  WideCharToMultiByte(CP_UTF8, 0, text, -1, result.data(), required, nullptr,
                      nullptr);
  return result;
}
#endif

constexpr int kUsageNameWidth = 15;
constexpr int kArgumentColumnWidth = 20;
constexpr std::string_view kAutoGeneratedHelp = "Auto generated help...";

struct ArgGroups {
  std::vector<ArgDef> positionals;
  std::vector<ArgDef> options;
};

auto SplitArgDefinitions(const std::vector<ArgDef>& definitions) -> ArgGroups {
  ArgGroups groups;
  for (const auto& def : definitions) {
    if (def.type == ArgType::kPositional) {
      groups.positionals.push_back(def);
    } else {
      groups.options.push_back(def);
    }
  }

  std::ranges::sort(
      groups.positionals,
      [](const ArgDef& left_def, const ArgDef& right_def) -> bool {
        return left_def.position_index < right_def.position_index;
      });

  return groups;
}

auto BuildUsagePrefix(const std::string& name) -> std::string {
  std::stringstream usage_stream;
  usage_stream << "  " << time_tracer::common::colors::kCyan << std::left
               << std::setw(kUsageNameWidth) << name
               << time_tracer::common::colors::kReset;
  return usage_stream.str();
}

auto NormalizeDescription(std::string description) -> std::string {
  if (description == kAutoGeneratedHelp) {
    return std::string{};
  }
  return description;
}

auto FormatOptionKeys(const std::vector<std::string>& keys) -> std::string {
  std::stringstream keys_stream;
  for (size_t index = 0; index < keys.size(); ++index) {
    keys_stream << keys[index];
    if (index + 1 < keys.size()) {
      keys_stream << ", ";
    }
  }
  return keys_stream.str();
}

void PrintUsageLine(const std::string& usage_prefix,
                    const std::string& description) {
  std::cout << usage_prefix << " " << description << "\n";
}

void PrintUsageSignature(const std::string& name, const ArgGroups& groups) {
  std::cout << "    " << time_tracer::common::colors::kBold << "Usage: " << name
            << time_tracer::common::colors::kReset;
  for (const auto& positional : groups.positionals) {
    std::cout << " " << time_tracer::common::colors::kCyan << "<"
              << positional.name << ">" << time_tracer::common::colors::kReset;
  }
  if (!groups.options.empty()) {
    std::cout << " " << time_tracer::common::colors::kGray << "[options]"
              << time_tracer::common::colors::kReset;
  }
  std::cout << "\n";
}

void PrintPositionals(const std::vector<ArgDef>& positionals) {
  if (positionals.empty()) {
    return;
  }

  for (const auto& def : positionals) {
    std::cout << "      " << std::left << std::setw(kArgumentColumnWidth)
              << (std::string(time_tracer::common::colors::kCyan) + "<" +
                  def.name + ">" +
                  std::string(time_tracer::common::colors::kReset))
              << ": " << def.help
              << (def.required
                      ? (std::string(time_tracer::common::colors::kGray) +
                         " (Required)" +
                         std::string(time_tracer::common::colors::kReset))
                      : "")
              << "\n";
  }
}

void PrintOptions(const std::vector<ArgDef>& options) {
  if (options.empty()) {
    return;
  }

  for (const auto& def : options) {
    std::cout << "      " << std::left << std::setw(kArgumentColumnWidth)
              << (std::string(time_tracer::common::colors::kCyan) +
                  FormatOptionKeys(def.keys) +
                  std::string(time_tracer::common::colors::kReset))
              << ": " << def.help << "\n";
  }
}

}  // namespace

#if defined(_WIN32) || defined(_WIN64)
void SetupConsole() {
  SetConsoleOutputCP(CP_UTF8);
  HANDLE h_out = GetStdHandle(STD_OUTPUT_HANDLE);
  if (h_out != INVALID_HANDLE_VALUE) {
    DWORD dw_mode = 0;
    if (GetConsoleMode(h_out, &dw_mode) != 0) {
      dw_mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(h_out, dw_mode);
    }
  }
}

auto GetUtf8Args() -> std::vector<std::string> {
  int argc = 0;
  LPWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &argc);
  if (argv == nullptr || argc == 0) {
    return {};
  }
  std::vector<std::string> args;
  args.reserve(static_cast<size_t>(argc));
  for (int i = 0; i < argc; ++i) {
    args.emplace_back(WideToUtf8(argv[i]));
  }
  LocalFree(static_cast<void*>(argv));
  return args;
}
#endif

void PrintFullUsage(
    const char* app_name,
    const std::vector<std::pair<std::string, std::unique_ptr<ICommand>>>&
        commands) {
  std::cout << time_tracer::common::colors::kBrightGreen
            << time_tracer::common::colors::kBold << "TimeTracer"
            << time_tracer::common::colors::kReset
            << ": A command-line tool for time data processing.\n\n";
  std::cout << time_tracer::common::colors::kBold
            << "Usage: " << time_tracer::common::colors::kReset << app_name
            << " " << time_tracer::common::colors::kCyan << "<command>"
            << time_tracer::common::colors::kReset
            << " [arguments...] [options...]\n\n";

  std::cout << time_tracer::common::colors::kBold
            << "Available Commands:" << time_tracer::common::colors::kReset
            << "\n";

  std::map<std::string, std::vector<std::pair<std::string, ICommand*>>>
      grouped_commands;
  for (const auto& [name, cmd_ptr] : commands) {
    if (!cmd_ptr) {
      continue;
    }
    grouped_commands[cmd_ptr->GetCategory()].emplace_back(name, cmd_ptr.get());
  }

  const std::vector<std::string> kCategoryOrder = {"Query", "Export",
                                                   "Pipeline", "General"};

  for (const auto& category : kCategoryOrder) {
    if (grouped_commands.contains(category)) {
      std::cout << "\n  " << time_tracer::common::colors::kBold << category
                << ":" << time_tracer::common::colors::kReset << "\n";
      for (const auto& [name, cmd] : grouped_commands[category]) {
        std::string description = NormalizeDescription(cmd->GetHelp());
        std::string usage_prefix = BuildUsagePrefix(name);
        PrintUsageLine(usage_prefix, description);
      }
      grouped_commands.erase(category);
    }
  }

  for (const auto& [category, cmds] : grouped_commands) {
    std::cout << "\n  " << time_tracer::common::colors::kBold << category << ":"
              << time_tracer::common::colors::kReset << "\n";
    for (const auto& [name, cmd] : cmds) {
      std::string description = NormalizeDescription(cmd->GetHelp());
      std::string usage_prefix = BuildUsagePrefix(name);
      PrintUsageLine(usage_prefix, description);
    }
  }

  std::cout << "\n"
            << time_tracer::common::colors::kBold
            << "Global Options:" << time_tracer::common::colors::kReset << "\n";
  std::cout << "  " << time_tracer::common::colors::kCyan << "--help, -h"
            << time_tracer::common::colors::kReset
            << "          Show this help message.\n";
  std::cout << "  " << time_tracer::common::colors::kCyan << "--version, -v"
            << time_tracer::common::colors::kReset
            << "       Show program version.\n";
  std::cout << "\nRun '" << app_name << " "
            << time_tracer::common::colors::kCyan << "<command> --help"
            << time_tracer::common::colors::kReset
            << "' for command-specific usage.\n";
}

void PrintCommandUsage(const std::string& command_name,
                       const ICommand& command) {
  std::cout << time_tracer::common::colors::kBrightGreen
            << time_tracer::common::colors::kBold << "Command: " << command_name
            << time_tracer::common::colors::kReset << "\n\n";

  ArgGroups groups = SplitArgDefinitions(command.GetDefinitions());
  std::string description = NormalizeDescription(command.GetHelp());

  if (!description.empty()) {
    std::cout << "  " << description << "\n\n";
  }

  PrintUsageSignature(command_name, groups);
  PrintPositionals(groups.positionals);
  PrintOptions(groups.options);
  std::cout << "\n";
}

}  // namespace ConsoleHelper
