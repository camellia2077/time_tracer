// cli/impl/utils/help_formatter.cpp
#include "help_formatter.hpp"

#include <algorithm>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string_view>

#include "cli/framework/core/arg_definitions.hpp"
#include "cli/framework/interfaces/i_command.hpp"
#include "common/ansi_colors.hpp"

namespace {
constexpr int kUsageNameWidth = 15;
constexpr int kArgumentColumnWidth = 20;
constexpr std::string_view kAutoGeneratedHelp = "Auto generated help...";

struct ArgGroups {
  std::vector<ArgDef> positionals;
  std::vector<ArgDef> options;
};

auto SplitArgDefinitions(const std::vector<ArgDef>& definitions) -> ArgGroups {
  ArgGroups groups;
  for (const auto& def : definitions) {
    if (def.type == ArgType::Positional) {
      groups.positionals.push_back(def);
    } else {
      groups.options.push_back(def);
    }
  }

  std::ranges::sort(
      groups.positionals,
      [](const ArgDef& left_def, const ArgDef& right_def) -> bool {
        return left_def.position_index < right_def.position_index;
      });

  return groups;
}

auto BuildUsagePrefix(const std::string& name) -> std::string {
  std::stringstream usage_stream;
  usage_stream << "  " << GREEN_COLOR << std::left << std::setw(kUsageNameWidth)
               << name << RESET_COLOR;
  return usage_stream.str();
}

auto NormalizeDescription(std::string description) -> std::string {
  if (description == kAutoGeneratedHelp) {
    return std::string{};
  }
  return description;
}

auto FormatOptionKeys(const std::vector<std::string>& keys) -> std::string {
  std::stringstream keys_stream;
  for (size_t index = 0; index < keys.size(); ++index) {
    keys_stream << keys[index];
    if (index + 1 < keys.size()) {
      keys_stream << ", ";
    }
  }
  return keys_stream.str();
}

void PrintUsageLine(const std::string& usage_prefix,
                    const std::string& description) {
  std::cout << usage_prefix << " " << description << "\n";
}

void PrintUsageSignature(const std::string& name, const ArgGroups& groups) {
  std::cout << "    Usage: " << name;
  for (const auto& positional : groups.positionals) {
    std::cout << " <" << positional.name << ">";
  }
  if (!groups.options.empty()) {
    std::cout << " [options]";
  }
  std::cout << "\n";
}

void PrintPositionals(const std::vector<ArgDef>& positionals) {
  if (positionals.empty()) {
    return;
  }

  for (const auto& def : positionals) {
    std::cout << "      " << std::left << std::setw(kArgumentColumnWidth)
              << ("<" + def.name + ">") << ": " << def.help
              << (def.required ? " (Required)" : "") << "\n";
  }
}

void PrintOptions(const std::vector<ArgDef>& options) {
  if (options.empty()) {
    return;
  }

  for (const auto& def : options) {
    std::cout << "      " << std::left << std::setw(kArgumentColumnWidth)
              << FormatOptionKeys(def.keys) << ": " << def.help << "\n";
  }
}
}  // namespace

void print_full_usage(
    const char* app_name,
    const std::vector<std::pair<std::string, std::unique_ptr<ICommand>>>&
        commands) {
  std::cout << GREEN_COLOR << "TimeTracer" << RESET_COLOR
            << ": A command-line tool for time data processing.\n\n";
  std::cout << "Usage: " << app_name
            << " <command> [arguments...] [options...]\n\n";

  std::cout << "Available Commands:\n";

  for (const auto& [name, cmd] : commands) {
    if (!cmd) {
      continue;
    }

    ArgGroups groups = SplitArgDefinitions(cmd->get_definitions());
    std::string description = NormalizeDescription(cmd->get_help());
    std::string usage_prefix = BuildUsagePrefix(name);

    PrintUsageLine(usage_prefix, description);
    PrintUsageSignature(name, groups);
    PrintPositionals(groups.positionals);
    PrintOptions(groups.options);
    std::cout << "\n";
  }

  std::cout << "Global Options:\n";
  std::cout << "  --help, -h          Show this help message.\n";
  std::cout << "  --version, -v       Show program version.\n";
}
