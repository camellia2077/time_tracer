## [v0.5.9] - 2026-02-13

### Summary
* 完成 tidy `batch_001`（`task_001` ~ `task_008`）并归档到 `tasks_done/batch_001`。
* C++ 侧完成 `formatter_config_payload` 的职责拆分与编排重构，降低重复逻辑。
* 修复 query/parser/validator 相关 tidy 问题（magic numbers、lambda 返回类型、参数可交换风险等）。

### Changed/Refactor
* `apps/time_tracer/src/infrastructure/reports/shared/factories/formatter_config_payload.*`
  * `Build*` / `BuildFromLoaded*` 保留编排流程（读输入 -> helper -> finalize）。
  
  * 新增模板化编排 helper：`BuildFromLoaded`、`BuildWithStrategy`、`InitializeConfigHeader`、`FinalizeConfig`。
  * 新增 `DayTypStatisticSizes`，替代 `PopulateDayTypConfig(int32_t, int32_t)`，避免参数顺序误用。
* `apps/time_tracer/src/infrastructure/reports/shared/factories/formatter_config_payload_*.cpp`
  * 按职责物理拆分：`fillers`、`cview`、`lifecycle/reset`。
  * `apps/time_tracer/src/infrastructure/CMakeLists.txt` 已新增对应编译单元。
* `apps/time_tracer/src/api/cli/impl/commands/query/data_query_repository.cpp`
  * 增加 `<stdexcept>`，并将多处 SQL `reserve(...)` magic number 常量化。
  * `BuildQualifiedClause` 参数改为语义更明确命名，降低可交换误用风险。
* `apps/time_tracer/src/application/parser/text_parser.cpp`
  * lambda 增加 trailing return type。
  * 时间解析局部常量命名统一（`kHour`/`kMinute`）并补括号提高可读性。
* `apps/time_tracer/src/infrastructure/config/validator/reports/strategies/base_strategy.cpp`
  * `IsValidHexColor` 内 lambda 改为 trailing return type。
* `apps/time_tracer/src/shared/types/version.hpp`
  * 版本升级到 `0.5.9`，更新时间 `2026-02-13`。

### CPP 修改代码
`apps/time_tracer/src/infrastructure/reports/shared/factories/formatter_config_payload.hpp`
```cpp
struct DayTypStatisticSizes {
  int32_t statistic_font_size = 0;
  int32_t statistic_title_font_size = 0;
};

template <typename ConfigType, typename PrepareFn, typename PopulateFn>
void BuildWithStrategy(uint32_t config_kind, ConfigType* config_data,
                       PrepareFn&& prepare_fn, PopulateFn&& populate_fn) {
  std::forward<PrepareFn>(prepare_fn)();
  std::forward<PopulateFn>(populate_fn)();
  FinalizeConfig(config_kind, config_data);
}
```

`apps/time_tracer/src/infrastructure/reports/shared/factories/formatter_config_payload.cpp`
```cpp
void FormatterConfigPayload::BuildFromLoadedDailyTypConfig(
    const DailyTypConfig& config) {
  BuildFromLoaded([&]() -> void {
    BuildWithStrategy(
        TT_FORMATTER_CONFIG_KIND_DAY_TYP, &day_typ_config_,
        [&]() -> void {
          FillDayLabels(config.labels, &day_labels_owned_);
          FillTypstStyle(config.fonts, config.layout, &typst_style_owned_);
          LoadKeywordColors(config.keyword_colors);
          LoadStatistics(config.statistics_items);
        },
        [&]() -> void {
          PopulateDayTypConfig(
              {.statistic_font_size = config.statistic_font_size,
               .statistic_title_font_size = config.statistic_title_font_size});
        });
  });
}
```

`apps/time_tracer/src/infrastructure/reports/shared/factories/formatter_config_payload_lifecycle.cpp`
```cpp
void FormatterConfigPayload::ResetToEmpty() {
  keyword_colors_owned_.clear();
  keyword_colors_c_.clear();
  statistics_owned_.clear();
  statistics_c_.clear();
  // ... labels/style/config reset ...
  RebuildConfigView(TT_FORMATTER_CONFIG_KIND_UNKNOWN, nullptr, 0U);
}
```

`apps/time_tracer/src/api/cli/impl/commands/query/data_query_repository.cpp`
```cpp
#include <stdexcept>

constexpr size_t kProjectCteWithProjectReserve = 640;
constexpr size_t kQueryDaysReserve = 256;
constexpr size_t kQueryDayClauseReserve = 24;

[[nodiscard]] auto BuildQualifiedClause(const char* table_alias,
                                        std::string_view column_name,
                                        const char* comparison_operator)
    -> std::string {
  std::string clause = BuildQualifiedName(table_alias, column_name);
  clause.push_back(' ');
  clause.append(comparison_operator);
  clause.append(" ?");
  return clause;
}
```

`apps/time_tracer/src/application/parser/text_parser.cpp`
```cpp
const int kHour =
    ((line[kTimeHourOffset] - '0') * 10) + (line[kTimeHourOffset + 1] - '0');
const int kMinute = ((line[kTimeMinuteOffset] - '0') * 10) +
                    (line[kTimeMinuteOffset + 1] - '0');

if (kHour > kMaxHour || kMinute > kMaxMinute) {
  ThrowParseError(line_number, line, "Time out of range");
}
```

`apps/time_tracer/src/infrastructure/config/validator/reports/strategies/base_strategy.cpp`
```cpp
return std::all_of(color_string.begin() + 1, color_string.end(),
                   [](char value) -> bool { return IsHexDigit(value); });
```
