# 设计模式与工程实践 (Design Patterns)

TimeTracer 利用多种经典设计模式来解决现代 C++ 环境中的架构复杂性挑战。

## 1. 管道模式 (Pipeline Pattern) - 应用层

这是系统最核心的模式，用于管理复杂的数据摄取流程。

*   **解决问题**: 摄取过程包含读取、语法验证、实体转换、逻辑链接、业务验证和持久化等多个不连续操作。传统的巨型函数极难维护。
*   **解决方案**: **`PipelineManager`** 执行一系列原子化的 **`Step`** 对象。
*   **核心优势**:
    *   **模块化**: 可以轻松添加新步骤（例如“同步到云端”），无需修改现有代码。
    *   **状态共享**: 所有步骤共享 **`PipelineContext`**，保证了全流程的数据一致性。
    *   **快速失败**: 系统可以在任何步骤报错时立即停机，防止错误数据污染数据库。

## 2. 策略模式 (Strategy Pattern) - 基础设施层

用于管理多种高度差异化的报表格式 (Markdown, LaTeX, Typst)。

*   **解决问题**: 不同输出格式由于语法不同导致渲染逻辑各异，但它们操作的底层数据（项目树）是同一套。
*   **解决方案**: **`ProjectTreeFormatter`** 内部持有一个 **`IFormattingStrategy`** 接口。
*   **核心优势**:
    *   **开闭原则 (OCP)**: 支持新格式（如 HTML）只需实现新策略，无需触动树遍历的核心算法。
    *   **动态加载**: 策略代码被封装在外部 DLL 中，程序通过 **`DllFormatterWrapper`** 在运行时动态加载，实现了物理层面的解耦。

## 3. 外观模式 (Facade Pattern) - 应用边界

通过简化接口，为 CLI 隐藏了复杂的内部核心流程。

*   **解决问题**: CLI 命令不应感知流水线是如何初始化的，也不应关心数据库是如何连接的。
*   **解决方案**: 如 **`ImportService`** 和 **`ReportHandler`** 等服务提供高层级的 API（如 `run_ingest()`），将复杂的跨模块调度隐藏在接口之后。

## 4. 依赖注入 (Dependency Injection)

虽然没有使用笨重的 DI 框架，但项目严格遵循了注入原则。

*   **实践方式**: 组件（如 `ConverterStep`）通过构造函数接收其所需的依赖对象（如 `AppConfig`、`FileSystem`）。
*   **核心优势**: 极大地提升了单元测试的便利性（可以使用 Mock 对象），且明确了对象生命周期的管控关系。

---

## 5. 开发工程规范

### 5.1 使用 `std::expected` 进行错误处理
我们避免在业务逻辑中使用异常来处理可预见的失败。通过 C++23 的 `std::expected<T, E>`，函数可以显式返回结果或错误码。这不仅提升了运行性能，也使调用方的逻辑处理更加直观和健壮。

### 5.2 严格的 Const 约束
领域模型（如 `DailyLog`）在传递时尽可能使用 `const &`。在管道流中，数据一旦经过当前步骤处理完成即视为不可变，这有效防止了难以追踪的副作用风险。